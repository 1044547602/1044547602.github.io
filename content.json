{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-11-03T11:45:25.046Z","updated":"2020-11-03T08:48:39.516Z","comments":true,"path":"2020/11/03/hello-world/","link":"","permalink":"http://example.com/2020/11/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Vue 生命周期详解","slug":"Vue-生命周期详解","date":"2020-11-03T09:06:03.000Z","updated":"2020-11-03T10:38:21.353Z","comments":true,"path":"2020/11/03/Vue-生命周期详解/","link":"","permalink":"http://example.com/2020/11/03/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"生命周期和钩子函数 钩子函数 描述 beforeCreate 在实例初始化之后，数据观测（data observer） 和 event/watch事件配置之前被调用 created 在实例创建完成后立即被调用，在这一步实例已经完成了： 数据观测、属性和方法的运算和 event/watch事件的回调， 但是$el属性目前不可见。 beforeMount 在挂载开始之前被调用 mounted 在挂载成功后被调用，el被新创建的vm.$el替换 beforeUpdate 数据更新之前调用 update 数据更新完成时调用，组件dom已经更新 activated 组件被激活时调用 deactivated 组件被移除时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 beforeCreate(实例创建前)实例组件刚开始创建，元素dom和数据都还没有初始化 应用场景：可以在这加个loading事件 created(实例创建后)数据data已经初始化完成，方法也已经可以调用，但是dom为渲染，在这个周期里面如果进行请求是可以改变数据并渲染，由于dom未挂载，请求过多或者占用时间过长会导致页面线上空白应用场景：在这结束loading，还做一些初始化，实现函数自执行 beforeMoute(元素挂载前)dom未完成挂载，数据初始化完成，但是数据的双向绑定还是空,这是因为vue采用了虚拟dom技术。 mouted(元素挂载后)数据和dom都完成挂载，在上一个周期占位的数据把值渲染进去，一般请求会放在这个地方，因为这边请求改变数据之后刚好能渲染。 beforeUpdate(实例更新前)只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候就会执行这个周期，如果没有数据改变不执行。 updated(实例更新后)只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的，beforeUpdated和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和死循环。 beforeDestory(实例销毁前)实例销毁之前调用，在这一步，实例仍然完全可用。 destory(实例销毁后)vue实例销毁后调用，调用后，Vue实例指示的所有内容都会解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default &#123; data()&#123; return&#123; message : &quot;钩子函数小测试&quot; &#125; &#125;, beforeCreate()&#123; console.group(&#x27;beforeCreate 创建前状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created() &#123; console.group(&#x27;created 创建完毕状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount() &#123; console.group(&#x27;beforeMount 挂载前状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted() &#123; console.group(&#x27;mounted 挂载结束状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate() &#123; console.group(&#x27;beforeUpdate 更新前状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&#x27;真实dom结构：&#x27; + document.getElementById(&#x27;app&#x27;).innerHTML); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated() &#123; console.group(&#x27;updated 更新完成状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&#x27;真实dom结构：&#x27; + document.getElementById(&#x27;app&#x27;).innerHTML); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy() &#123; console.group(&#x27;beforeDestroy 销毁前状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed() &#123; console.group(&#x27;destroyed 销毁完成状态 ------------&gt;&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"堆和栈和宏微任务","slug":"堆和栈和宏微任务","date":"2020-11-03T09:06:03.000Z","updated":"2020-11-03T14:23:09.749Z","comments":true,"path":"2020/11/03/堆和栈和宏微任务/","link":"","permalink":"http://example.com/2020/11/03/%E5%A0%86%E5%92%8C%E6%A0%88%E5%92%8C%E5%AE%8F%E5%BE%AE%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"9.17堆与栈12345678910class A &#123; String i = &quot;op&quot;; void func(String s) &#123; s = &quot;&quot;+9; &#125; static void test() &#123; A a = new A(); a.func(a.i); &#125;&#125; 变量i,s,a在堆还是在栈中？ 第8行执行完后a.i的值是什么？ 解析 1、考察js堆与栈：栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null以及对象变量的指针，堆主要存储object 所以字符串变量i,s以及对象指针a都存在栈中，new出来的对象开辟内存存在堆上，对应地址是指针a存的内容 2、考察参数传递按值传递：a是A类的实例，所以a.i=’op’，a.func(a.i)这句执行函数，把a.i作为参数传递，该函数会复制一个变量，两个变量完全独立，所以在函数体里只是把复制的那个变量（一个新的局部变量）改变为’op9’,在函数体外的a.i并没有被改变 另外补充说明ECMAScript中所有函数的参数都是按值传递的——《高程3》，其实对于参数是对象的情况，实际上也是按值传递，把传参的指针复制出一个完全独立的变量，只是存的内容和传参对象地址一摸一样 https://www.cnblogs.com/chenwenhao/p/7009606.html 宏任务与微任务 https://segmentfault.com/a/1190000023938456","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]}],"categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]}